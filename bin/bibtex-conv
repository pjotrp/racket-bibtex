#!/usr/bin/env racket
#lang racket

(require json)
(require srfi/1) ;; for drop-right

(define verbose-mode (make-parameter #f))
(define keyword-mode (make-parameter #f))
(define eval-string  (make-parameter #f))

(define files-to-compile
  (command-line
   #:program "bibtex-conv"
   #:once-each
   [("-v" "--verbose") "Compile with verbose messages"
                       (verbose-mode #t)]
   [("-k" "--keyword") kw "Filter on keyword"
                       (keyword-mode kw)]
   [("-e" "--eval") e "Filter on s-exp"
                       (eval-string e)]
   #:args args args
))

#|
A JSON record

[
  {
    "DOI": "10.1007/978-1-4939-9074-0_21",
    "URL": "http://www.ncbi.nlm.nih.gov/pubmed/31278680",
    "author": [
      {
        "family": "Prins",
        "given": "P."
      },
      {
        "family": "Smant",
        "given": "G."
      },
      {
        "family": "Jansen",
        "given": "R. C."
      }
    ],
    "container-title": "Methods Mol Biol",
    "id": "Prins:2019",
    "issued": {
      "date-parts": [
        [
          2019
        ]
      ]
    },
    "keyword": "genenetwork",
    "page": "635-652",
    "title": "<span class=\"nocase\">Systems Genetics for Evolutionary Studies</span>",
    "type": "article-journal",
    "volume": "1910"
  },

|#

(define single-bibentries
  ;; Convert bibentries to ID based hash
  ;; removes duplicates and turn back to list
  (let [(records (read-json))]
    (for/hash ([(rec) records])
      (values (hash-ref rec 'id) rec)
      )))

(define (remove-nocase s)
  (string-replace (string-replace s "<span class=\"nocase\">" "") "</span>" ""))

(define (authors lst)
  ;; "Meh"
  (for/list ([author lst])
    (let* [(given  (string-replace (hash-ref author 'given "") " " ""))
           (family (hash-ref author 'family ""))
           (fullname (string-append given family))
           ]
      (match fullname
        ["P.Prins"   (string-append "_" fullname "_")]
        [_ fullname]
        )
    )))

(define (url text uri)
  (if uri
      (string-append "[[" uri "][" text "]]")
      text
      ))

(define (pretty bib id #:prefix pre)
  (let [(s (hash-ref bib id #f))]
    (if (string? s)
        s
        ""))
  )

(define (pretty2 bib id [pre ""] [post ""])
  (let [(s (hash-ref bib id #f))]
    (if (string? s)
        (string-append pre s post)
        ""))
  )

(define (year bib)
  (first (first (hash-ref (hash-ref bib 'issued "") 'date-parts))))

(define short-list
  (for/list ([(id bib) single-bibentries])
    bib))

(define (sorted-list list)
  (sort list
        >
        #:key (lambda (b) (year b))
        )
  )

(define (filtered-list list)
  (cond
    [(string? (keyword-mode))
      (filter (lambda (b) (string-contains? (hash-ref b 'keyword "xxx") (keyword-mode)))
              list)]
;    [(string? (eval-string))
;       (filter (lambda (b)(eval (read (open-input-string (eval-string)))) )
;              list]
    [else list]
      ))

(define (make-doi doi)
  (string-append "https://doi.org/" doi)
  )


; (display (eval (read (open-input-string "(+ 1 2)"))))

(for ([(bib) (filtered-list (sorted-list short-list))])
  (display "1. ")
  (let* [(title (hash-ref bib 'title))
         (url1  (hash-ref bib 'URL #f))
         (url2  (if url1
                    url1
                    (make-doi (hash-ref bib 'DOI #f))))
        ]
    (display (url (remove-nocase title) url2)))
  (display " by ")
  (let [(auths (authors (hash-ref bib 'author)))]
    (display (string-join (drop-right auths 1) ", "))
    (display " and ")
    (display (last auths))
    )
  (display (pretty2 bib 'container-title ", @@html:<span class=\"journal\">@@"
                    "@@html:</span>@@"))
  (display " (@@html:<span class=\"year\">@@")
  (display (year bib))
  (display "@@html:</span>@@)")
  (display (pretty2 bib 'volume " Vol"))
  (display (pretty2 bib 'page " p. "))
  (display (pretty2 bib 'edition " (" " edition)"))
  (display (pretty2 bib 'DOI ", DOI: "))
  (display (pretty2 bib 'note " (*" "*)"))
  #|
  (display (match bib
             [(hash-table ('DOI doi)) doi]
             [_ ""]))
  |#
  (newline)
  )

(let [(ns (make-base-namespace))]
  (eval (read (open-input-string "(display \"test\")")) ns))
