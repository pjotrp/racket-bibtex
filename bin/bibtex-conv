#!/usr/bin/env racket
#lang racket

(require json)
(require srfi/1) ;; for drop-right

#|
(define verbose-mode (make-parameter #f))

(define files-to-compile
  (command-line
   #:program "bibtex-conv"
   #:once-each
   [("-v" "--verbose") "Compile with verbose messages"
                       (verbose-mode #t)]
   #:args args args
))

(display files-to-compile)

(define (reader func)
  (for ([line (in-lines (current-input-port))])
    (func line))
  (for ([fn (current-command-line-arguments)])
    (call-with-input-file fn
      (lambda (port)
        (for ([line (in-lines port)])
          (func line))
        ))))

(define-syntax-rule (argf/each line body)
  (reader (lambda (line)
            body)))

(argf/each line
  (write (string-append "-" line)))
|#

;; "-a""-b""-c"#f

#|

(for ([line (in-port read-line)])
  (display line)
  (newline)
  )



|#

;; (string->jsexpr (port->string))

#|

A JSON record

[
  {
    "DOI": "10.1007/978-1-4939-9074-0_21",
    "URL": "http://www.ncbi.nlm.nih.gov/pubmed/31278680",
    "abstract": "Systems genetics combines high-throughput genomic data with genetic analysis. In this chapter, we review and discuss application of systems genetics in the context of evolutionary studies, in which high-throughput molecular technologies are being combined with quantitative trait locus (QTL) analysis in segregating populations.The recent explosion of high-throughput data-measuring thousands of RNAs, proteins, and metabolites, using deep sequencing, mass spectrometry, chromatin, methyl-DNA immunoprecipitation, etc.-allows the dissection of causes of genetic variation underlying quantitative phenotypes of all types. To deal with the sheer amount of data, powerful statistical tools are needed to analyze multidimensional relationships and to extract valuable information and new modes and mechanisms of changes both within and between species. In the context of evolutionary computational biology, a well-designed experiment and the right population can help dissect complex traits likely to be under selection using proven statistical methods for associating phenotypic variation with chromosomal locations.Recent evolutionary expression QTL (eQTL) studies focus on gene expression adaptations, mapping the gene expression landscape, and, tentatively, define networks of transcripts and proteins that are jointly modulated sets of eQTL networks. Here, we discuss the possibility of introducing an evolutionary “prior” in the form of gene families displaying evidence of positive selection, and using that prior in the context of an eQTL experiment for elucidating host-pathogen protein-protein interactions.Here we review one exemplar evolutionairy eQTL experiment and discuss experimental design, choice of platforms, analysis methods, scope, and interpretation of results. In brief we highlight how eQTL are defined; how they are used to assemble interacting and causally connected networks of RNAs, proteins, and metabolites; and how some QTLs can be efficiently converted to reasonably well-defined sequence variants.",
    "author": [
      {
        "family": "Prins",
        "given": "P."
      },
      {
        "family": "Smant",
        "given": "G."
      },
      {
        "family": "Arends",
        "given": "D."
      },
      {
        "family": "Mulligan",
        "given": "M. K."
      },
      {
        "family": "Williams",
        "given": "R. W."
      },
      {
        "family": "Jansen",
        "given": "R. C."
      }
    ],
    "container-title": "Methods Mol Biol",
    "id": "Prins:2019",
    "issued": {
      "date-parts": [
        [
          2019
        ]
      ]
    },
    "keyword": "genenetwork",
    "page": "635-652",
    "title": "<span class=\"nocase\">Systems Genetics for Evolutionary Studies</span>",
    "type": "article-journal",
    "volume": "1910"
  },

|#

(define single-bibentries
  ;; Convert bibentries to ID based hash
  ;; removes duplicates and turn back to list
  (let [(records (read-json))]
    (for/hash ([(rec) records])
      (values (hash-ref rec 'id) rec)
      )))

(define (remove-nocase s)
  (string-replace (string-replace s "<span class=\"nocase\">" "") "</span>" ""))

(define (authors lst)
  ;; "Meh"
  (for/list ([author lst])
    (string-append (hash-ref author 'given "") " " (hash-ref author 'family ""))
    ))

(define (url text uri)
  (if uri
      (string-append "[[" uri "][" text "]]")
      text
      ))

(define (pretty bib id #:prefix pre)
  (let [(s (hash-ref bib id #f))]
    (if (string? s)
        s
        ""))
  )

(define (pretty2 bib id [pre ""])
  (let [(s (hash-ref bib id #f))]
    (if (string? s)
        (string-append pre s)
        ""))
  )

(define (year bib)
  (first (first (hash-ref (hash-ref bib 'issued "") 'date-parts))))

(define short-list
  (for/list ([(id bib) single-bibentries])
    bib))

(define (sorted-list list)
  (sort list
        >
        #:key (lambda (b) (year b))
        )
  )

(for ([(bib) (sorted-list short-list)])
  (display "- ")
  (let [(title (hash-ref bib 'title))]
    (display (url (remove-nocase title) (hash-ref bib 'URL #f))))
  (display " by ")
  (let [(auths (authors (hash-ref bib 'author)))]
    (display (string-join (drop-right auths 1) ", "))
    (display " and ")
    (display (last auths))
    )
  (display (pretty2 bib 'container-title ", "))
  (display " (")
  (display (year bib))
  (display ")")
  (display (pretty2 bib 'volume " Vol "))
  (display (pretty2 bib 'page " p. "))
  (display (pretty2 bib 'DOI ", DOI:"))
  #|
  (display (match bib
             [(hash-table ('DOI doi)) doi]
             [_ ""]))
  |#
  (newline)
  )
